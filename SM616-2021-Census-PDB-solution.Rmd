---
title: "PDB stratified sample"
output:
  html_document:
    df_print: paged
    toc: true
  html_notebook:
    toc: true
---

## Libraries

```{r libraries, message=FALSE, warning=FALSE}
libs <- c('tidyverse', 'here', 'optimx')
for( l in libs) {
  library(l, character.only = TRUE)
}
```

## PDB data

```{r pdb, message=FALSE, warning=FALSE}
PDB <- read_csv('pdb2020trv2_us.csv')
```

## Sample design targets

```{r targets}
target_n <- 2500
target_black <- 500
target_hisp <- 500
```

We need to create a sample of adults in the state of Connecticut,
with the target of `r target_n`, 
and oversample targets for racial/ethnic minorities:

* Black/African American: `r target_black`
* Hispanic: `r target_hisp`

## Connecticut

```{r CT}
PDB %>% filter(State=='09', 
               !is.na(Tot_Population_ACS_14_18), 
               Tot_Population_ACS_14_18 > 0, 
               !is.na(Low_Response_Score) ) %>% 
  mutate( 
    pct_NH_black_alone = NH_Blk_alone_ACS_14_18 / Tot_Population_ACS_14_18,
    pct_hisp           = Hispanic_ACS_14_18 / Tot_Population_ACS_14_18,
    pct_minority       = pct_NH_black_alone + pct_hisp
  ) -> PDB_CT
```

## Sampling design foundation

Four strata:

1. high Black/AA: 
  cutoff parameter for the census tracts with the highest concentration of NH Black
2. high Hispanic: 
  cutoff parameter for the census tracts with the highest concentration of Hispanics
  that are not in strata 1
3. mixed minority: other tracts with moderate to high concentration of minorities
4. white: tracts with low density of NH Blacks and Hispanics

## Optimization target

For the given sample size of `r target_n`, we want to minimize the
unequal weighting design effect $1+CV^2$.

## Sandbox 

```{r strata4, echo=FALSE}
above_black <- 0.4
above_hisp  <- 0.6
above_minor <- 0.3
PDB_CT %>% mutate(strata4 = case_when(
  pct_NH_black_alone > above_black ~ 1,
  pct_hisp  > above_hisp  ~ 2,
  pct_minority > above_minor ~ 3,
  TRUE ~ 4
  )
) -> PDB_CT4
PDB_CT4 %>% group_by(strata4) %>%
  summarize(
    tracts = n(),
    pop   = sum(Tot_Population_ACS_14_18),
    black = sum(NH_Blk_alone_ACS_14_18),
    hisp  = sum(Hispanic_ACS_14_18),
    RR    = 1 - weighted.mean(x=Low_Response_Score,
                              w=Tot_Population_ACS_14_18, 
                              na.rm=TRUE)/100) %>% 
  mutate(
    n_field = case_when(
      strata4 == 1 ~ 800,
      strata4 == 2 ~ 800,
      strata4 == 3 ~ 800,
      strata4 == 4 ~ 1000
    ),
    n_total = floor(n_field * RR),
    n_black = floor(n_field * RR * black / pop),
    n_hisp  = floor(n_field * RR * hisp / pop)
  ) -> CT4_sample
```

Using the cutoffs:

1. high Black/AA: `r above_black`
2. high Hispanic: `r above_hisp`
3. mixed minority: `r above_minor`
4. white: all others

```{r print_design}
bind_rows( CT4_sample %>% mutate(strata4=as.character(strata4)),
           CT4_sample %>% select(starts_with("n_"), tracts, pop, black, hisp) %>% 
           summarize_all(sum) %>% mutate(strata4='Total')) %>% knitr::kable()
```

## Effective sample size

```{r UWE_DEFF}
(CT4_sample %>% 
  mutate(weight=pop/n_total) %>% 
  summarise( n_wgt = sum(n_total*weight), 
             n_wgt2 = sum(n_total*weight*weight),
             n = sum(n_total) ) %>% 
  mutate(UWE_DEFF = n_wgt2 * n / (n_wgt*n_wgt) ) %>% 
  select(UWE_DEFF) %>% unlist() -> UWE_DEFF)
```

This is an improvement over a two-strata design that had DEFF above 2.0.

## Assemble to a function

To apply optimization algorithms available in R, one needs to have
a function that responds to the input parameters and returns the value
to be minimized.

```{r obj_function}
design4 <- function( 
  above_black, above_hisp, above_minor,
  lop1, lop2, lop3,
  minsize = 30,
  data = PDB_CT,
#  target_n = target_n, target_black=target_black, target_hisp=target_hisp,
  verbose = FALSE) {
  
  if (above_black<0 | above_black > 1 | above_hisp<0 | above_hisp >1 | 
      above_minor<0 | above_minor > 1 ) return( list(fobj=1e20) )
  
  # strata proportions
  p1 <- exp(lop1)/(exp(lop1)+exp(lop2)+exp(lop3)+1)
  p2 <- exp(lop2)/(exp(lop1)+exp(lop2)+exp(lop3)+1)
  p3 <- exp(lop3)/(exp(lop1)+exp(lop2)+exp(lop3)+1)
  p4 <- exp(0)/(exp(lop1)+exp(lop2)+exp(lop3)+1)
  if ( abs( p1 + p2 + p3 + p4 - 1 ) > 1e-5 ) {
    stop("Strata proportions are misformed: ", paste(p1,p2,p3,p4, collapse=", "))
  }
  
  # stratify
  data %>% mutate(strata4 = case_when(
    pct_NH_black_alone > above_black ~ 1,
    pct_hisp  > above_hisp  ~ 2,
    pct_minority > above_minor ~ 3,
    TRUE ~ 4
  ) ) %>% select(GIDTR,
                 Tot_Population_ACS_14_18,
                 NH_Blk_alone_ACS_14_18,
                 Hispanic_ACS_14_18,
                 Low_Response_Score,
                 strata4) -> data4
  
  # first pass at sample size
  data4 %>% group_by(strata4) %>%
    summarize(
      tracts = n(),
      pop   = sum(Tot_Population_ACS_14_18),
      black = sum(NH_Blk_alone_ACS_14_18),
      hisp  = sum(Hispanic_ACS_14_18),
      RR    = 1 - weighted.mean(x=Low_Response_Score,
                                w=Tot_Population_ACS_14_18, 
                                na.rm=TRUE)/100) %>% 
    mutate(
      n1_field = case_when(
        strata4 == 1 ~ 1000*p1,
        strata4 == 2 ~ 1000*p2,
        strata4 == 3 ~ 1000*p3,
        strata4 == 4 ~ 1000*p4
      ),
      n1_total = (n1_field * RR),
      n1_black = (n1_field * RR * black / pop),
      n1_hisp  = (n1_field * RR * hisp / pop)
    ) %>% ungroup() -> data4_sample

  n1 <- sum(data4_sample$n1_total)
  
  # second pass at the sample size
  data4_sample %>% mutate(
    n2_field = n1_field*target_n/n1,
    n2_total = n2_field * RR,
    n2_black = n2_field * RR * black / pop,
    n2_hisp  = n2_field * RR * hisp / pop
  ) -> data4_sample
  if (is.na(sum(data4_sample$n2_total))) {
    print(data4_sample)
    stop("Total sample size does not match up: ", sum(data4_sample$n2_total) )
  }
  if( abs( sum(data4_sample$n2_total) - target_n ) > 1e-4 ) {
    print(data4_sample)
    stop("Total sample size does not match up: ", sum(data4_sample$n2_total) )
  }
  
  # DEFF
  data4_sample %>% 
    mutate(weight=pop/n2_total) %>% 
    summarise( n_wgt = sum(n2_total*weight), 
               n_wgt2 = sum(n2_total*weight*weight),
               n = sum(n2_total) ) %>% 
    mutate(UWE_DEFF = n_wgt2 * n / (n_wgt*n_wgt) ) %>% 
    select(UWE_DEFF) %>% unlist() -> UWE_DEFF
  names(UWE_DEFF) <- ''
  
  # penalties
  fobj <- UWE_DEFF
  ### for missing the oversample targets
  fobj <- fobj + log( 1 + min( c( sum(data4_sample$n2_black)-target_black, 0 ) )^2 )
  fobj <- fobj + log( 1 + min( c( sum(data4_sample$n2_hisp) -target_hisp,  0 ) )^2 )
  
  ### for strata sizes that are too small
  for(i in 1:nrow(data4_sample)) {
    fobj <- fobj + log(1 + min( c(unlist(data4_sample[i,"tracts"])-minsize, 0) )^2 )
  }
  
  ### for absent strata
  fobj <- fobj + (nrow(data4_sample)-4)^2
  
  if (is.na(fobj)) {
    print(c(  above_black, above_hisp, above_minor,
        lop1, lop2, lop3))
    print(data4_sample)
    stop("Invalid objective function value ", fobj )
  }

  # return
  rlist  <-       list(
        above_black = above_black,
        above_hisp  = above_hisp,
        above_minor = above_minor,
        n_total     = sum(data4_sample$n2_total),
        n_black     = sum(data4_sample$n2_black),
        n_hisp      = sum(data4_sample$n2_hisp),
        deff        = UWE_DEFF,
        p1          = p1,
        p2          = p2,
        p3          = p3,
        p4          = p4,
        fobj        = fobj,
        sample_design = (data4_sample %>% select( - starts_with('n1_')))
      )
  if (verbose) {
    print(data4_sample)
    print(rlist)
  }
  
  return( rlist )  
}
```

Try some values:
```{r try_some}
design4(
  above_black=0.4, above_hisp=0.4, above_minor=0.3, minsize = 30,
  lop1=-0.5, lop2=-0.5, lop3=-0.5,
  verbose = TRUE)
design4(
  above_black=0.4, above_hisp=0.5, above_minor=0.5, minsize = 30,
  lop1=-0.85, lop2=-0.85, lop3=-0.85,
  verbose = TRUE)
```

## Optimization

The above function needs to be made compatible with `stats::optim()` and
`library(optimx)`, which expect a function that accepts a vector of parameters,
and returns a scalar value of the function to be optimized.

```{r scalar_return}
design4_opt <- function(par) {
  
  design4_return <- design4(
    above_black = par[1], above_hisp=par[2], above_minor=par[3],
    lop1=par[4], lop2=par[5], lop3=par[6]
  )
  
  return(design4_return$fobj)
}
design4_opt(c(0.4,0.4,0.3,-0.5,-0.5,-0.5))
```

Let us now try the different optimization routines and methods available.

### stats::nlm()

```{r stats_nlm}
(nlmo <- stats::nlm(f=design4_opt,p=c(0.4,0.4,0.3,-0.5,-0.5,-0.5)))
```

The help file states:

> code == 3: 
last global step failed to locate a point lower than estimate. 
Either estimate is an approximate local minimum of the function 
or steptol is too small.
> code == 4:
iteration limit exceeded.

The implied design is:

```{r stats_nlm_design}
design4(
  above_black=nlmo$estimate[1], 
  above_hisp =nlmo$estimate[2], 
  above_minor=nlmo$estimate[3], 
  minsize = 30,
  lop1=nlmo$estimate[4], 
  lop2=nlmo$estimate[5], 
  lop3=nlmo$estimate[6])
```

```{r optimx}
(xo <- optimx(fn=design4_opt,par=c(0.4,0.4,0.3,-0.5,-0.5,-0.5)))
```

### optim: Nelder-Mead

```{r nelder_mead}
(nmo <- optim(fn=design4_opt,par=c(0.4,0.4,0.3,-0.5,-0.5,-0.5),method="Nelder-Mead",
  control=list(maxit=5000,trace=0)))
```

The help file states:

> convergence == 0 indicates successful completion.

The implied design is:

```{r stats_nmo_design}
design4(
  above_black=nmo$par[1], 
  above_hisp =nmo$par[2], 
  above_minor=nmo$par[3], 
  minsize = 30,
  lop1=nmo$par[4], 
  lop2=nmo$par[5], 
  lop3=nmo$par[6])
```

DEFF is very successful at `r nmo$value`.

### optim: simulated annealing

```{r optim_sann}
(sanno <- optim(fn=design4_opt,par=c(0.4,0.4,0.3,-0.5,-0.5,-0.5),method="SANN",
  control=list(temp=0.2,tmax=40,trace=3,maxit=5000)))
```

The implied design is:

```{r stats_sanno_design}
design4(
  above_black=sanno$par[1], 
  above_hisp =sanno$par[2], 
  above_minor=sanno$par[3], 
  minsize = 30,
  lop1=sanno$par[4], 
  lop2=sanno$par[5], 
  lop3=sanno$par[6])
```

### optim: BFGS

BFGS moved only one of the thresholds:

```{r optim_bfgs}
(bfgso <- optim(fn=design4_opt,par=c(0.4,0.4,0.3,-0.5,-0.5,-0.5),method="BFGS"))
```

The design effect is OK at `r bfgso$value`.

The implied design is:

```{r stats_bfgs_design}
design4(
  above_black=bfgso$par[1], 
  above_hisp =bfgso$par[2], 
  above_minor=bfgso$par[3], 
  minsize = 30,
  lop1=bfgso$par[4], 
  lop2=bfgso$par[5], 
  lop3=bfgso$par[6])
```


### optim: L-BFGS-B

```{r optim_lbfgsb}
(boxo <- optim(fn=design4_opt,par=c(0.4,0.4,0.3,-0.5,-0.5,-0.5),method="L-BFGS-B",
  lower=c(0.2,0.2,0.2,-5,-5,-5), upper=c(0.9,0.9,0.9,5,5,5),control=list(trace=3)))
```

Optimization could not get very far.
The design effect isn't that "great" at `r boxo$value`.

The implied design is:

```{r stats_boxo_design}
design4(
  above_black=boxo$par[1], 
  above_hisp =boxo$par[2], 
  above_minor=boxo$par[3], 
  minsize = 30,
  lop1=boxo$par[4], 
  lop2=boxo$par[5], 
  lop3=boxo$par[6])
```

## R Markdown

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. 
When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk 
or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
